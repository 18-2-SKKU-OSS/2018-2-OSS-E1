섹션: 지뢰를 조심하세요!

Dictionary에서 반복하는 동안 수정합니다.

이것은 정확히 8번 작동하고 멈춥니다.

설명:

동시에 편집하는 Dictionary의 반복은 지원되지 않습니다.

Dictionary가 키를 더 보유하도록 크기를 조정하는 시점이기 때문에 8번 실행합니다(삭제 항목이 8개 있으므로 크기 조정 필요). 이것은 실제로 구현 세부 사항입니다.

삭제된 키를 처리하는 방법과 크기 조정은 Python 구현마다 다를 수 있습니다.

자세한 내용은 유사한 예를 자세히 설명하는 StackOverflow 스레드를 참조하십시오.

완고한 del 연산자

결과 1.

드디어 삭제되었습니다. 첫 번째 x 삭제 시도에서 __del__를 호출하여 저장한 내용이 무엇인지 짐작하셨을 수 있습니다. 그것은 이 예에 약간의 난이도를 증가하게 할 수 있습니다.

2. 
이제 삭제되었습니다.

설명:

del x는 x.__del__()을 직접 호출하지 않습니다.

del x가 발생할 때마다 Python은 x에 대한 기준 카운트를 하나씩, x의 기준 카운트가 0에 도달하면 x.__del__()를 감소시킵니다.

두 번째 출력 snippet에서 y.__del__() 델 y가 발생할 때 참조 카운트가 0에 도달하지 못하도록 해서 이전 문(>>> y)이 동일한 개체에 대한 또 다른 참조를 만들기 때문에 호출되지 않습니다.

전역 변수를 호출하는 것은 현재 참조를 파괴시기기 때문에 우리는 "Deleted"가 출력되는 것을 알 수 있습니다.

반복하는 동안 list 항목 삭제

결과:

당신은 [2,4]의 결과값을 예측할 수 있습니까?

설명:

반복하고 있는 개체를 변경하는 것은 결코 좋은 생각이 아닙니다.대신 올바른 방법은 개체의 복사본을 반복하는 것이며, list_3[:]은 바로 그렇게 하는 것 입니다.

del,remove,pop사이 간 차이점:

delvar_name은(는) Local 또는 Global namespace에서 var_name의 묶음을 제거합니다.(따라서 list_1은 영향을 받지 않습니다).

remove는 특정 인덱스가 아닌 첫 번째 일치 값을 제거하고 값을 찾지 못하면 ValueError가 발생합니다.

pop은 특정 인덱스에서 요소를 제거하고 반환하며, 유효하지 않은 인덱스가 지정된 경우 IndexError를 발생시킵니다.

왜 결과값이 [2,4]일까요?

목록 반복은 index별로 수행되며, list_2 또는 list_4에서 1을 제거하면 목록의 내용은 현재 [2, 3, 4]입니다. 나머지 요소는 아래로 이동한다. 즉, 2는 지수 0, 3은 지수 1이다. 다음 번 반복에서는 색인 1(3번)을 살펴보게 되므로, 2번 항목은 완전히 생략됩니다. 목록 순서에서 모든 대체 요소에서도 유사한 일이 일어날 것입니다.

예제를 설명하는 이 StackOverflow 스레드를 참조하십시오.
Python의 Dictionary와 관련된 유사한 예는 이 StackOverflow 스레드를 참조하십시오.

루프 변수가 누출됐습니다!

1.
결과
하지만 x는 반복문 밖의 영역에서 정의되지 않습니다.

2.
결과:

3.
결과(Python 2.x):

결과(Python 3.x):

설명:

