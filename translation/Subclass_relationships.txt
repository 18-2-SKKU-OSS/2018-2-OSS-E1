â–¶ Subclass relationships *
â–¶ í•˜ìœ„ í´ë˜ìŠ¤ ê´€ê³„ *

Output:
ê²°ê³¼:

The Subclass relationships were expected to be transitive, right? (i.e., if A is a subclass of B, and B is a subclass of C, the A should a subclass of C)
í•˜ìœ„ ê³„ê¸‰ ê´€ê³„ëŠ”  ì „ì´ì ì¸ ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤. (ì¦‰, Aê°€ Bì˜ í•˜ìœ„ í´ë˜ìŠ¤ì´ê³  Bê°€ Cì˜ í•˜ìœ„ í´ë˜ìŠ¤ì¸ ê²½ìš° AëŠ” Cì˜ í•˜ìœ„ í´ë˜ìŠ¤ì—¬ì•¼ í•©ë‹ˆë‹¤.)

ğŸ’¡ Explanation:
ğŸ’¡ ì„¤ëª…:

Subclass relationships are not necessarily transitive in Python. 
í•˜ìœ„ ê³„ê¸‰ ê´€ê³„ê°€ ë°˜ë“œì‹œ íŒŒì´ì¬ì—ì„œ ì „ì´ì ì¸ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. 

Anyone is allowed to define their own, arbitrary __subclasscheck__ in a metaclass.
ëˆ„êµ¬ë“  ë©”íƒ€í´ë˜ìŠ¤ì—ì„œ ì„ì˜ì˜ __subclasscheck__ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

When issubclass(cls, Hashable) is called, it simply looks for non-Falsey "__hash__" method in cls or anything it inherits from.
evaluubclass(cls, Hashable)ë¥¼ í˜¸ì¶œí•˜ë©´ cls ë˜ëŠ” clsì—ì„œ non false "__hash__" ë©”ì„œë“œë¥¼ ê²€ìƒ‰í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.

Since object is hashable, but list is non-hashable, it breaks the transitivity relation.
ê°œì²´ëŠ” í•´ì‹œí•  ìˆ˜ ìˆì§€ë§Œ ëª©ë¡ì€ í•´ì‹œí•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ì „ì´ì ì¸ ê´€ê³„ê°€ ëŠì–´ë²„ë¦½ë‹ˆë‹¤.

More detailed explanation can be found here.
ìì„¸í•œ ì„¤ëª…ì€ ì—¬ê¸°ì—ì„œ ì°¾ì•„ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.